gmTCP-1.e.0	2005/5/2 (EST) - ghkim
----------------

	앞으로는 __gmUSE_PUBLIC_QUEUE__는 절대 사용하지 않고,
	__gmMESSAGE_IOCP__는 항상 사용할 것이다.


1. gmQueue::mf__ShiftEx에서, Get이 아니라 Peek인 경우에
m__head값을 저장한 후에 변경해야 하는 버그 수정

2.1 __gmCRYPT__을 정의함으로써, 데이터를 소켓에 쓸 때,
그리고 데이터를 소켓으로부터 읽었을 때, 모두 데이터를 암호화한다.
알고리즘은 RC4(스트림방식)이고, 암호화 키는 특정 문자열을 해시처리해서 만들어진다.

	쓸 때:
		WSASend를 호출해서 소켓에 쓸 때, 이전에 암화화되었으나
		아직 소켓에 써지지 않은 데이터를 제외한 데이터를 암화화한다.

		WSASend을 처리결과를 보면 소켓에 쓰여지지 않은
		데이터의 크기(gmPseudoTCP::m__dwUnwritten)를 알 수 있다.

		보내는 큐에 데이터를 넣은 직 후, 암호화한다.


	읽을 때:
		WSARecv의 처리한 직 후, 소켓으로부터 읽혀진 "모든" 데이터의 암호화를 푼다.


	* 암화화는 연속적인 데이터를 덮어쓰므로, 두 경우 모두 이를 고려해야 한다.
	왜냐하면 WSASend나 WSARecv는 일반적으로 두 개의 연속적인 데이터를 사용한다.

	** Encrypt, Decrypt의 쌍을 맞추기기 어렵다. 적절한 크기의 불럭단위로 하면 가능할 수 있다.
	하지만 응용프로그램에서 보낸 메시지가 일부는 암화화되어 보내지고,
	일부는 보내지 않을 수 있으므로 이 방법도 힘들다.

	예를 들어 세 번에 걸쳐 암화화한 메시지를 한 번에 풀려고 하면 문제가 생긴다.(?)


2.2 각 메시지별로 암호화한다.
	쓸 때:
		메시지를 큐에 넣기 직전에 암호화한다.

		* 문제가 생겼을 때, 데이터가 먼저 암호화되는 걸 막기위하여,
		gmQueue::mf__Push에서 마지막 단계에서 암호화하도록 했다.

	읽을 때:
		메시지를 가져올 때 암호화한다.
